#lang scribble/lp2

@(require "../literacy.rkt")

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@(define Puzzle:1 "找到携带食物能提供最多卡路里的精灵，并计算他所携带的卡路里总和")

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@handbook-root-story{第一天：计点卡路里}

@aoc-desc[1
 #:keywords ["文学式编程" "函数式编程" "REPL" "列表" "sexp" "递归函数" "高阶函数"]]

新手远征第一天，故事主线任务不会太复杂，因此我们多花点时间来习惯本书的写作风格。

@margin-note*{@fallacy{特别提醒，“语言只是工具”是一句广为流传的谬论。}}
本节的关键词不多，但都很令人费解。比如，那个“文学式编程”乍一听就很不合理，说
编程跟数学关系密切可以理解，但跟文学的关系在哪里呢？这个关系就是@term-name{写作}，
人与人的交流依托自然语言，人与计算机交流依托的是程序语言。写作的本质是用文字
表达作者的思想或意图，除了熟练度上的差异，写作本身应该与语言无关，但要考虑读者
的接受程度。优秀的作者还会考虑@focus{语言自身的思维和惯例}。

@aoc-defterm[#:origin "Literate Programming"]{文学式编程}讲究
以人为本，用作者自己的写作思路来写程序，同样阅读程序的人也能更容易理解程序。
@margin-note*{@linebreak[]@idea{程序代码应当要方便人类阅读，其次才是计算机执行。}}
这样的程序源码分为散文和代码两部分，后者给编译程序看，它们会自动将
散落在文章各处的代码碎片组装成正确的程序；前者（和后者共同）给人类读者看。
比如你现在正在阅读的本书就是践行@tech{文学式编程}的成果。此外，在 Racket
自身优势的加持下，文中示例程序的运行结果也是最终程序的直接执行结果（而非额外
运行程序之后再把结果复制粘贴过来）。

接下来我们通过完成第一天的主线任务来具体感受一下。

从散文里抽取代码碎片的程序在将它们正确组装成程序之前要先有一个起点碎片，在我写
作本节的程序里，它看起来是这个样子的：

@handbook-chunk[<calorie:*>
                (module advent racket 
                  <定义函数find-top-calorie>
                  <定义函数find-top-calories>)]

其中用尖括号（@sign{< >}）括起来的部分就是散落在本节各处的代码碎片
的名字，其本质跟变量名没有什么不一样。@id{<calorie:*>}是第一天任务的起点，
这段碎片定义了一个名为 @id{advent} 的模块，并指定该模块的书写语言为
@id{racket}@handbook-footnote{Racket 是@term-name{语言导向}的语言，
 除了用与它同名的默认语言，你还可以换成 @id{python}、@id{datalog}等很多其他语言。}；
紧接着的两个碎片名分别指向解决第一天的两个谜题的代码碎片，后文会详细说明。

代码碎片可以出现在任何地方，但是起点碎片必须是本节的第一个碎片，并且只有实际用到的
碎片才会出现在最终程序里。那些没被使用的碎片的价值是继续留在本书里给读者看，它们或许
提供了另一种思路。

原始故事作为我们学习编程的情景，以嵌套形式放在本书中，以避免跟正文内容互相干扰：

@story{丛林杂草丛生，没法使用交通工具，也没法空降，因此精灵们传统上只能徒步远征。
 当小船快靠岸时，精灵们开始清点存货，食物是重点清点对象之一。具体来说，
 也就是每只精灵携带食物的卡路里含量。}

@story{精灵们轮流把自己携带的各种肉类、点心、口粮等食物的卡路里数写在纸上，
 一行一项，不同精灵之间用空行隔开。}

@story{当有精灵饿了或馋了时，他们需要知道问谁去要零食，即需要知道谁带的卡路里最多。
 请帮助精灵们@question{@|Puzzle:1|}。}

情景部分会用特殊颜色说清楚我们需要解决的问题是什么。比如第一个问题是@question{@|Puzzle:1|}，
从后文可以得知，对该问题的解决就对应着之前给出的碎片@id{<定义函数find-top-calorie>}。

故事中的例子会从情景部分抽出来放在正文部分，作为我们思考的素材。
比如，精灵们写出了如下一份食物清单：

@tabular[#:style 'boxed
         (list (list @racket[1000]) (list @racket[2000]) (list @racket[3000])
               (list @hspace[1])
               (list @racket[4000])
               (list @hspace[1])
               (list @racket[5000]) (list @racket[6000])
               (list @hspace[1])
               (list @racket[7000]) (list @racket[8000]) (list @racket[9000])
               (list @hspace[1])
               (list @racket[10000]))]

从这份清单可以看到，有五只精灵，以及他们所携带食物的卡路里信息：

@itemlist[
          
 @item{第一只精灵带了三种食物，卡路里含量分别为 @racket[1000], @racket[2000] 和 @racket[3000]，总计 @racket[6000] 卡。}  
 @item{第二只精灵只带了一种食物，卡路里含量为 @racket[4000] 卡。}
 @item{第三只精灵带了两种食物，卡路里含量分别为 @racket[5000] 和 @racket[6000]，总计 @racket[11000] 卡。}
 @item{第四只精灵带了三种食物，卡路里含量分别为 @racket[7000], @racket[8000] 和 @racket[9000]，总计 @racket[24000] 卡。}
 @item{第五只精灵也只带了一种食物，含 @racket[10000] 卡。}
 
 ]

于是，经过简单比较，我们可以得到第一个谜题的答案：
第四只精灵携带的食物卡路里含量最高，达到了 @racket[24000] 大卡。

我们暂时先不考虑用什么思路来求解，就先设想一下，
如果不写程序，你会怎么解决这个问题？
要具体到你的眼睛是如何“阅读”食物清单的。
阅读清单的方式多种多样，其中比较自然的一种是：
@desc{读取清单第一行，如果读到的是数字，说明这行里有卡路里含量信息，
 应当更新当前精灵携带的卡路里信息；
 否则，根据实际情况更新最大卡路里信息，并重置精灵卡路里。
 接着读取下一行，重复上述过程，直到没有更多内容为止}，
此时的最大卡路里即为谜题的答案。

不难看出，阅读清单的过程有着明显的循环特征，不妨称作@name{读取-判断-更新循环}，
或缩写为 @id{rpul}（read-predicate-update loop）。
于是，函数 @id{find-top-calorie}的主体结构就有了，
而它的输入参数显然就是与卡路里清单关联的输入源。
与之相关的代码碎片@id{<定义函数find-top-calorie>}看起来就是这样的，
它的内部包含了另一段碎片@id{<读取-判断-更新循环>}：

@handbook-chunk[<定义函数find-top-calorie>
                (code:comment #,($argv [/dev/datin "与卡路里清单关联的输入源"]))
                (define find-top-calorie
                  (lambda [/dev/datin]
                    <读取-判断-更新循环>))]

既然程序语言也被称为语言，那想必也是可以跟其他语言相互翻译的。
从写作的角度来讲，编程就是@idea{把你希望计算机完成的任务翻译成计算机能理解的语言}。
绝大多数程序语言的语法都比较死板，有很多固定格式要遵守。
咋一看，这是“不说人话”，其实是对简洁和精准的追求。
计算机执行任务不应该产生歧义，
一个总是误解你的程序没有存在价值（除非你就是要造一个没法跟你愉快玩耍的机器人）。

@handbook-chunk[<读取-判断-更新循环>
                (let rpul (<变量初始化>)
                  (define line <读取一行>)
                  (if <判断是否有内容>
                      (let ([cal <尝试提取卡路里信息>])
                        (if <判断是否是正整数>
                            <更新精灵卡路里，递推下一轮>
                            <更新最大卡路里，递推下一轮>))
                      <更新最大值>))]

仔细阅读有关@id{<读取-判断-更新循环>}的代码碎片，
除了一些固定格式，它详细列出了我们需要“逐句翻译”的地方。
不过，这毕竟是一个循环任务，在翻译的时候需要考虑清楚循环的开始和结束；
而且，人脑和计算机都有各自的习惯，在大多数语言里，计算机对执行细节的要求更高，
因此无法做到完全“逐句翻译”。

接下来，我们只需把那些需要翻译的部分按字面意思一个个翻译成代码即可。
首先是@desc{变量初始化}。本题简单，直接考虑问题本身，而无需准备辅助变量。

@handbook-chunk[<变量初始化>
                [self:cal 0] (code:comment "当前精灵携带的卡路里总数")
                [peak:cal 0] (code:comment "当前已知最高卡路里数")]

@desc{读取一行}就是字面直译，@desc{从 @var{/dev/datin} 里面读取一行}。

@handbook-chunk[<读取一行>
                (read-line /dev/datin)]

函数 @racket[read-line] 的求值结果，要么是一个字符串，要么是一个特殊值 @tamer-defterm{EoF}(End of File）,
表示@term-name{文件结尾}。因此@desc{判断是否有内容}的意思是@desc{读到的内容是否是一个字符串}，空行对应空字符串。

@handbook-chunk[<判断是否有内容>
                (string? line)]

当读到的是字符串时，就尝试将字符串转化为(十进制)数字。在强类型语言里，这一步必须明确写出来。
也存在一些弱类型语言，跟人一样会自动把看起来像数字的文字转化成数字，但这种自动转化经常变成调试程序的灾难。

@handbook-chunk[<尝试提取卡路里信息>
                (string->number line 10)]

函数 @racket[string->number] 的求值结果，要么是一个数（不一定是整数），要么是布尔型常量 @racket[#false]。
在本题中，卡路里肯定是正整数，空行被转化成什么不重要。

@handbook-chunk[<判断是否是正整数>
                (exact-positive-integer? cal)]

像@id{string?}和@id{exact-positive-integer?}这样
@desc{接受一个参数，返回布尔型常量（@racket[#true]或@racket[#false]），
用以检查输入参数是否满足条件}的函数称为@aoc-defterm[#:origin "Predicate Function"]{谓词函数}。
在 Racket 中，谓词函数的名字通常以@litchar{?}结尾。

在翻译那两段跟@term-name{更新}有关的碎片之前，我们先要对函数式编程有个初步的了解。
@aoc-defterm[#:origin "Functional Programming"]{函数式编程}通过定义函数来求解问题，
只是这里的函数是@focus{严格意义上的数学函数}。
相较于常规语言里的函数，数学函数的典型特征是，
有定义域和值域来约束输入参数和返回值，
且@focus{变量的值一定不会被函数修改}。
按照这个说法，用常规语言的术语来说，
函数式编程中应该没有@term-name{变量}只有@term-name{常量}才对。
但其实，@focus{函数式编程中的变量也是数学中的变量}，
即代数、方程中出现的类似@math{x、y、z}的符号。
在不同的前提条件下，它们可以取不同的值，是为“变”；
然而，一但条件确定，它们的值也就不再改变，
进而导致对函数的求值也不会改变。
而常规语言中的变量，它们只是给内存中的某个位置起了个名字，
它们的值取决于那块内存地址里存放的内容。
打个比方，数学变量相当于身份证上的姓名，
不同人的名字可以相同可以不同，
但每个人的名字在第一次确定之后（一般）不可更改，
点名时也（基本）可以确定你就是你；
程序语言变量相当于屋子的门牌号，
屋子里面有什么取决于什么样的人或物能进去。

如果你上过常规编程课，想必你肯定花了好一段时间才适应，
等号（@sign{=}）在数学和在程序语言中的不同。
别气馁，我也经历过这样的瞎折腾。
不过，现在，我们需要重新回归数学思维。
@tech{函数式编程}的本质是@focus{代数变换}，
等号（@sign{=}）就是关系运算符，没有@term-name{赋值}语义，
也就不会出现诸如@${i = i + 1}这样令人困惑的语句
（除非你在用反证法推理）。
那么，用数学语言如何表达上述迷惑用法呢？
答案是@focus{@${i_{n+1} = i_n + 1}}，
这种递推写法在数列或数学归纳法中极为常见。

既然提到了数学归纳法，那就必然要提及另一个跟它关系密切的编程概念：
@aoc-defterm[#:origin "Recursive Function"]{递归函数}。
这是一类特殊函数，它们通过@focus{对自身求值来将复杂问题拆解成规模更小的同类子问题以各个击破}。
递归函数不是新鲜概念，现代常规语言里都有，但除了开销太大外，
常规语言的递归函数有个致命缺陷：它们调用自身的次数不能太多，否则程序会奔溃。
因此，@thus{常规语言往往优先使用循环来解决递归问题}。
函数式语言里的递归函数则没有那些缺陷，毕竟函数才是人家的灵魂。
反倒是普通循环不被函数式待见，因为普通循环必然要修改变量，
这严重违背了@focus{数学变量不可变}原则。
铺垫了这么多，我只是想说，@focus{递归函数和循环是一回事}。

课间休息，打一套醉拳放松一下。

回归主线任务，重新审视一下@id{<读取-判断-更新循环>}的固定格式。
@form{let} 就是数学求解中常用的@id{设}或@id{令}，
如果顺便给 @form{let} 起个名字，就会同时定义一个同名函数，
并用假设的自变量作为参数来调用它。也就是说，
一元函数 @id{find-top-calorie} 内部嵌套了一个二元函数 @id{rpul}，
它才是问题求解的本体。

@desc{更新当前精灵卡路里}实际做的事是@desc{将读到的卡路里数累加到自己的卡路里总和里去}，
并保持最大卡路里不变。用数学语言说，即：@$${ \mathit{self}_{n+1} & = \mathit{self}_n + \mathit{cal}_n \\
 \mathit{peak}_{n+1} & = \mathit{peak}_n }

根据@tech{函数式编程}对递归函数和普通循环的偏好，
子函数 @id{rpul} 会在@desc{每一轮循环结束时再次对自己求值以启动下一轮循环}。
而循环的性质保证了，@desc{本轮循环结束时的变量值即是下轮循环中变量的初始值}，即：
@$${ \mathit{rpul}(\mathit{self}_{n+1}, \mathit{peak}_{n+1}) }

@handbook-chunk[<更新精灵卡路里，递推下一轮>
                (rpul (+ self:cal cal) peak:cal)]

同理，@desc{更新最大卡路里}的数学原理是：@$${ \mathit{self}_{n+1} & = 0 \\
 \mathit{peak}_{n+1} & = \max\{\mathit{self}_n, \mathit{peak}_n\} }

@handbook-chunk[<更新最大卡路里，递推下一轮>
                (rpul 0 <更新最大值>)]

无论如何，变量@variable{self:cal}和@variable{peak:cal}的值至始至终都没有变过，
只不过它们在各自循环中的使命完成之后就不再现身，而被下一轮循环中的自己@term-name{替换}掉了。
就好比，电影续作中的主角还在，也仍然叫那个名，但是主角演员被其他人@term-name{替换}走了。

撇开数学原理不谈，本题简单到毫无悬念。
但是，你注意到，为什么@id{<确定最大值>}要单独拿出来说吗？
它在子函数@id{rpul}中出现了两次，
一次是碰到空行时，一次是碰到@tech{EoF}时。
例子里只强调了精灵与精灵之间用空行分隔，
那最后一只精灵后面有没有空行呢？
其实没有，因为每只精灵写清单时只负责与前面的精灵隔开，不负责后面的。
因此，文件没有更多内容时，最后一只精灵携带的卡路里还没有清点，
需要单独处理一下。

@handbook-chunk[<更新最大值>
                (max self:cal peak:cal)]

子函数@id{rpul}的命名借鉴了Lisp语系传统的
@aoc-defterm[#:origin "Read-Eval-Print Loop" "REPL"]{读取-求值-打印循环}。
即，每一轮循环要做的事是：读取用户输入的表达式，计算此表达式的结果，再把结果打印出来。
这个循环看起来不太起眼，但在很多场合能极大的提高你的开发效率，
因为你不用单独准备一个完整的测试程序就可以立即检查函数的运行是否符合预期。
因而时至今日，好多语言都抄了一个类似的东西。
比如打开 @exec{idle}，那就是 Python 的 @tech{REPL}，
只是它用了另一个更常见的名字，叫做@term-name{Shell}。

在本书中，Racket 的 @tech{REPL} 用于直接在书里运行我们主线任务中的代码。
它看起来是这个样子的：

@tamer-action[(let ([a 1])
                (a . = . 2))]

提示符（@sign{>}）后面的就是用户输入的表达式，
本例我们演示的是@desc{@tech{函数式编程}中的等号（@sign{=}）就是数学中的关系运算符}，
因此@${a = 2}并不是将@math{a}的值修改为@racket[2]，
而是@term-name{比较}@math{a}与@racket[2]是否相等。
因此，在假设了@${a = 1}的前提下，
表达式的求值结果是布尔型常量@racket[#false]，
@tech{REPL}直接把它打印在表达式下方了。

于是，接下来我们实际运行一下主线任务中的函数来验证它是否正确：

@tamer-action[#:requires ["../aoc.rkt"]
              (with-aoc-data-from "mee/01.cc.ex.aoc" #:do
                find-top-calorie)]

表达式的执行结果是 @racket[24000]，
跟例子中的结论一样。
最后是相对真实的运行：

@tamer-action[(with-aoc-data-from "mee/01.cc.aoc" #:do
                find-top-calorie)]

第一个谜题求解完毕。提交这个答案，解锁第二个谜题。

@story{当你在冥思苦想求解第一个谜题时学到的爆炸性信息时，
 精灵们又开始搞事了：
 天，这么点零食迟早会被吃完的！
 这可不行，你必须再找到另外两个所带食物提供了最大卡路里的精灵。
 这样，一只精灵的零食吃完了，
 咱还有俩可以继续腐败。}

@story{请帮助精灵们@question{找出携带食物所提供卡路里最多的前三只精灵，
  并计算他们所带食物所能提供的卡路里总和。}}

根据题意可知，例子中携带食物提供卡路里最多的三只精灵分别是第四只（@racket[24000] 卡）、
第三只（@racket[11000] 卡）和第五只（@racket[10000] 卡），总计 @racket[45000] 大卡。

精灵们的这两次提问都比较拗口，但是不难看出，用第二个谜题的思路来说，第一个谜题其实就是
@desc{携带食物所提供的卡路里最多的前一只精灵所能提供的卡路里总和}。
换句话说，这两个谜题其实是一个问题，差别只在于数量的多少。
于是，自然而然地，@focus{不同数量的同类型数据可以构成数组、列表、元组等复合类型}。
在不同的语言里，这些数据类型都可以是很趁手的选择。

现在，我想先讲点特别的。
你已经注意到了，Racket 代码写起来很奇怪，括号套着括号。
是的，它确实奇怪，这也是它不流行的原因之一，
但这种写法与数学的渊源却颇为深刻。

真程序语言起源于上世纪50年代，
但那些无外乎是对机器语言的直白翻译（用英文单词来替代@racket[0]@racket[1]串），
语法也是互相借鉴。
总之，没有特别亮眼的创新，
特别是缺乏数学的美感。

Racket 是 Lisp 语系的一种方言，
也可以一直追溯到50年代，人工智能研究领域。
不过，至于 Lisp 到底是怎么来的，恐怕已经永远消失在历史的迷雾中了。
现在公认的看法是麻省理工学院的 John McCarthy 于1959年立项，
直接基于数学而发明的全新的程序语言。动机很简单，影响却极为深远。
@idea{程序编制者应该关注问题本身，而不是被迫淹没在琐碎的机器细节里，
而从人类思维到机器思维之间的脏活，该由程序语言来搞定}。
在 Lisp 的所有方言里，Racket 这一支最为看重数学理论的优雅和纯粹，
（最近十年 Racket 开始弥补在实用性方面的不足）。
总之，现今存在的绝大多数语言，它们宣传中那些出神入化的所谓“新”东西，
都是Lisp玩剩下了才被那些语言的作者发现而抄过去的（还抄不好）。

Lisp 全称@term-name{表处理语言}（LISt Processing），
言下之意，列表是其基础数据类型，
用它@focus{求解问题的思路也就转化成了对列表的操作}。
@aoc-defterm[#:origin "List"]{列表}是一种容器，
里面@focus{按顺序}存放着很多数据（的值），可以相同也可以不同。
列表中的元素通过@focus{自然数}@term-name{索引}来访问，
索引从@racket[0]开始计数；
列表中所含数据的个数称为@term-name{列表的长度}。

@note{@term-name{列表}是个容易引起混乱的名字，
 它在不同语言、不同场景表示的并非相同的东西，有时甚至会影响你的思路。
 比如，Python 的列表（@id{list}）是@term-name{顺序表}；
 C++ 的列表（@id{std::list}）是@term-name{链表}。
 它俩涵盖了绝大多数情况。
 而专业处理列表的 Lisp/Racket，
 其列表（@id{list}）是@term-name{广义表}。}

Lisp/Racket 特殊在，它们连语法都写成了广义表的形式。
任意一类括号（@sign{() [] @|"{}"|}）都能用来界定广义表，
广义表里的元素可以是常规数据，也可以是另一个广义表，甚至是自己套自己。
这种写法称作@aoc-defterm[#:origin "Symbolic Expression" "sexp"]{符号表达式}，
是@focus{函数式递归在文法上的实现}。

文法设计方面的话题我不在这展开，直接说重点。
我们从幼儿园就开始学习的算术表达式，其写法属于中缀记法，总是把操作符写在操作数的中间；
而 @tech{sexp} 是一种前缀记法，@focus{总是把操作符写在操作数的前面}。
前缀记法的优点很多，比如无需考虑运算符优先级；
方便计算机处理（你如果想写个计算器程序也会更希望用户输入前缀表达式）。
最关键的是，它@focus{确实更契合数学运算的语义}。

实际上，数学学得越深，数学表达式的写法就越五花八门。
比如一元二次方程的求根公式和三角恒等式：
@$${
 \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} \\
 \sin^2\theta + \cos^2\theta = 1
}
就已经混进去了不少奇怪的东西，肯定不能都算中缀记法。

初等数学中的二元运算符往往也能推广到多元场景。
以加法为例，@desc{计算十个数的和}，与@desc{计算两个数的和}，
在计算法则上没有任何区别。
但用中缀记法，需要写十个数、九个加号：
@$${ a + b + c + d + e + f + g + h + i + j }
而写成 @tech{sexp}，只需要十个数、一个加号（以及一对括号充当边界）：
@centered{@racket[(+ a b c d e f g h i j)]}
还有一些二元运算，没有约定俗成的记号，就只能写成函数形式。
比如求最大公约数的@${ \gcd(a, b) }，
这不就很像前缀记法了吗？括号不能省，还得增加逗号来分隔参数。
@thus{@tech{sexp} 统一了以上（和其他）所有奇奇怪怪的写法：
 广义表的第一个元素代表操作符（函数），
 其余所有元素都是该操作符（函数）的操作数（参数）}，漂亮。

这段典故跑得有点偏，
还是赶紧来完成主线任务吧，
精灵们吃不到零食该急眼了。

既然花了大量时间来说@tech{列表}，
那求解第二个谜题的工具就是它了，
以后我们也会经常用它解决别的问题。
此外，在定义函数的时候，
也应当在原题的基础之上适当考虑通用性。
@desc{找一个}也好，@desc{找三个}也罢，都只是@desc{找n个}的特定案例。
因此，相较于求解第一个谜题的@id{find-top-calorie}函数，
这个复数形式的@id{find-top-calories}函数增加了一个参数@variable{n}：

@handbook-chunk[<定义函数find-top-calories>
                (code:comment #,($argv [/dev/datin "与卡路里清单关联的输入源"] [n "需要关注的高卡路里精灵数量"]))
                (define find-top-calories
                  (lambda [/dev/datin n]
                    (let rpul ([self:cal 0]
                               <初始化卡路里列表>)
                      (define line (read-line /dev/datin))
                      (if (string? line)
                          (let ([c (string->number line 10)])
                            (if (exact-positive-integer? c)
                                (rpul (+ self:cal c) calories)
                                (rpul 0 <更新卡路里列表>)))
                          <高卡路里合计>))))]

从上面这段碎片里，我们也可以大致看出求解第一个谜题时被拆得稀碎的代码组装成最终程序后的样子。

算法逻辑大同小异，区别在于子函数@id{rpul}里代表最大值的参数类型从整型变为了列表型：

@handbook-chunk[<初始化卡路里列表>
                [calories (make-list n 0)]]

最终结果变为了对@desc{最大值列表的求和运算}。
前面在比较@tech{sexp}和算术表达式的差异时提到了多操作数加法的写法。
这就来了个具体例子，本题中列表里只有正整数，数的列表即是@term-name{数列}。
数学有个专门的符号来表达@desc{对含有n项的数列求和}：
@$${ \sum_{i=1}^n a_i }
是不是感觉大脑突然宕机了？
不用管它，用@tech{sexp}写要简洁得多：

@handbook-chunk[<高卡路里合计>
                (apply + <更新卡路里列表>)]

加法操作符（@id{+}）前面多了一个@id{apply}函数，
后面的参数从多个数字变成了一个列表。
函数@id{apply}的功能是将列表里的数都取出来，
再作为操作数全部喂给操作符@id{+}。
这个表达式的结果就是对列表中的所有数@desc{执行加法运算}的结果。
这时候用@tech{REPL}来演示更好：

@tamer-action[(code:comment "对空列表求和得到0")
              (apply + (list))
              (apply + (list 1 2 3))
              (apply + (list 4 5 6))
              (apply + (list 1 2 3 4 5 6))]

还没结束，这段代码碎片引出了@tech{函数式编程}中的另一个重要概念：
@aoc-defterm[#:origin "Higher-Order Function"]{高阶函数}。
这类函数的输入参数中至少有一个必须是其他函数，或者返回值是一个函数。
@tech{高阶函数}是@tech{函数式编程}中实现代码复用的强力工具，
也是初学者理解@tech{函数式编程}的一道砍。

最后，但依然重要的一步，
针对列表设计的确定最大值逻辑：
@desc{列表中如果存在比当前精灵所携带的卡路里小的元素就替换之}。

不太好理解的样子。
不过，再给自己一点耐心，不妨先拿出纸笔来模拟一下这个过程。
一开始，列表里全是@racket[0]，无论哪只精灵的卡路里清点好了，
他都是第一名，会占据列表的第一个位置。
以后每有一只精灵准备好了，
他都要跟那只精灵比，
直到比输了被替换走。
如果第一名很幸运没被换走，
那同样的戏码会在列表的第二个位置处上演。
依次类推。

以上模拟是为了理解问题，
真正解决之道还在于@focus{将该问题转化为对列表的操作}。
已知@focus{列表元素通过索引来访问}，
则问题转化为@desc{找到需要替换的卡路里位置索引}，
如果这个位置真的存在，就@desc{替换该位置的卡路里}。即：

@handbook-chunk[<更新卡路里列表>
                (let ([idx <查找被替换卡路里的索引>])
                  (if (not idx)
                      calories
                      <替换该位置的卡路里>))]

那么，这时候为什么不自己写一个@tech{递归函数}来求解呢？
因为太麻烦了呀。前面我们手写操作文件的@tech{读取-判断-更新循环}
是因为只有我们碰到了这个问题，因而也只能我们自己来解决。
而@tech{列表}作为一种基础数据类型，
@term-name{查找}和@term-name{更新}都是标准操作，
不仅仅我们用得到，全世界所有使用@tech{列表}的人都用得到。
因此提供@tech{列表}的语言也会同时帮我们操作@tech{列表}，
我们只需要弄清楚@desc{（对列表）做什么}而不用浪费时间去想
@desc{具体怎么做}（不同类型的列表做法还真不一样）。
这就是@tech{函数式编程}和@tech{列表}带给我们的思维的提升。

@note{如果你用C语言做任务，
 那就真的要自己去写循环模拟上面我们理解问题的那个过程。}

@handbook-chunk[<查找被替换卡路里的索引>
                (index-where calories (curryr < self:cal))]

@tech{高阶函数}@id{index-where}的第二参数是一个@tech{谓词函数}，
用于依次判断各个位置上的元素是否满足条件。
如果有满足条件的元素，
返回第一个满足条件的元素所在的位置索引，
否则返回@racket[#false]。

@tech{高阶函数}@id{curryr}用在这里有点犯规，它的输入和输出都是函数。
仅就本题而言，它接受小于操作符（@id{<}）和精灵卡路里，
返回一个符合题意的@tech{谓词函数}。
小于操作符（@id{<}）至少需要两个操作数，我们只能提供第二个。
返回的@tech{谓词函数}接受第一个操作数，
由@racket[index-where]在检查列表时依次提供。

@handbook-chunk[<替换该位置的卡路里>
                (list-set calories idx self:cal)]

@term-name{替换}操作比较简单。
唯一需要强调的是，Racket @focus{列表型值在创建之后就不可变了}，
因而每一次替换都会导致列表被复制一份，
在复制过程中踢掉旧元素换上新元素。

至此，任务终于完成了：

@tamer-action[(with-aoc-data-from "mee/01.cc.aoc" #:do
                find-top-calories 3)]

我们还可以对比一下这两个谜题在逻辑上的一致：

@tamer-action[(with-aoc-data-from "mee/01.cc.aoc" #:do
                find-top-calorie)
              (with-aoc-data-from "mee/01.cc.aoc" #:do
                find-top-calories 1)]

不过，切记，@focus{比较两种算法的执行结果并不是严密地证明}。
两个结果相等也可能说明两个算法都不对，只不过用题目给的数据测试不出来。
比如，本次解谜就有可能掉进前文所说的陷阱里，导致漏算了最后一只精灵，
而那只精灵又恰好不影响最终结果。@linebreak[]


文中出现了好几处理论性较强的段落，
你现在看不懂才是正常现象，
有待我们在后续任务中慢慢体会。
最重要的是，
@idea{我在帮你种@tech{函数式编程}的种子，
 相信他日定会发芽}。

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@handbook-reference[]
